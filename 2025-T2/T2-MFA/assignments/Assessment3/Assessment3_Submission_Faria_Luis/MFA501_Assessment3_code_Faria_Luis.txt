############################
app.py
############################
import streamlit as st

st.set_page_config(
    page_title="EigenAI Portal",
    layout="centered",
    page_icon="ü§ñ",
    initial_sidebar_state="expanded"
)

from views import home, set1Problem1, set1Problem2, set2Problem1, set2Problem2, set3Problem1

# ---- Sidebar Header ----
logo_url = "https://github.com/lfariabr/masters-swe-ai/blob/master/2025-T2/T2-MFA/projects/eigenai/assets/logo2.png?raw=true"
# logo_url = "assets/logo2.png"
st.sidebar.image(logo_url, width="stretch")
st.sidebar.markdown("---")

# ---- Sidebar Menu ----
menu = st.sidebar.radio(
    "üìÇ Select a screen:", [
    "üåÄ Portal",
    
    # Assessment 2A
    "[set1]problem-1",
    "[set1]problem-2",
    
    # Assessment 2B
    "[set2]problem-1",
    "[set2]problem-2",
    
    # Assessment 3
    "ai-problem-set",
], index=0)

# ---- View Routing ----
if menu == "üåÄ Portal":
    home.display()

if menu == "[set1]problem-1":
    set1Problem1.display_s1p1()

if menu == "[set1]problem-2":
    set1Problem2.display_s1p2()

if menu == "[set2]problem-1":
    set2Problem1.display_s2p1()

if menu == "[set2]problem-2":
    set2Problem2.display_s2p2()
    
if menu == "ai-problem-set":
    set3Problem1.display_s3p1()

# ---- Footer ----
st.sidebar.markdown("---")
st.sidebar.markdown("[![LinkedIn](https://img.shields.io/badge/LinkedIn-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white)](https://linkedin.com/in/lfariabr)")
st.sidebar.caption("luisfaria.dev")

############################
set3Problem1.py
############################
import streamlit as st
import time
from resolvers.constructor import (
    create_random_state, calculate_cost, generate_neighbors, 
    get_target_image, TARGET_IMAGE, format_state_text, format_state_simple
)
from resolvers.hill_climber import HillClimber

def display_s3p1():
    st.title("üéì Hill Climbing Algorithm")
    st.caption("Assessment 3 - AI Problem Set")
    
    st.markdown("""
    **Objective:** Reconstruct a 10√ó10 binary image using Hill Climbing algorithm.
    
    > *HC is a local search algorithm that iteratively moves to better neighboring* 
    > *states until no improvement can be made. Here, we start with a random binary* 
    > *image and flip **one pixel at a time** to minimize the difference from the target.*
    """)
    
    with st.expander("*‚öôÔ∏è Configuration*"):
        use_complex = st.checkbox(
            "üî• Use Complex Pattern",
            value=False,
            help="Use checkerboard pattern instead of circle (creates local optima challenges)"
        )
    
        use_stochastic = st.checkbox(
            "‚ö° Enable Stochastic Sampling",
            value=False,
            help="Sample random neighbors instead of evaluating all (faster but may miss optimal moves)"
        )
        
        if use_stochastic:
            sample_size = st.slider(
                "üé≤ Sample Size (neighbors per iteration)",
                min_value=10,
                max_value=100,
                value=50,
                step=10,
                help="Number of neighbors to evaluate per iteration (out of 100 total)"
            )
        else:
            sample_size = 100
    
    # Get selected target image
    target_image = get_target_image(use_complex=use_complex)
    
    # --- Display Target Image --
    pattern_name = "Complex (Checkerboard)" if use_complex else "Simple (Circle)"
    st.write(f"üéØ Target Image: {pattern_name}")
    st.caption("This is the pattern we're trying to reconstruct")
    
    col_target1, col_target2 = st.columns(2)
    with col_target1:
        st.markdown("**Text Representation:**")
        st.code(format_state_text(target_image), language="text")
    
    with col_target2:
        st.markdown("**Binary Matrix:**")
        st.code(format_state_simple(target_image), language="text")
    
    # --- Algorithm Parameters ---
    st.markdown("---")
    st.markdown("##### Algorithm Parameters")
    
    col1, col2, col3 = st.columns(3)
    with col1:
        try:
            max_iter = int(st.text_input("Max Iterations", "1000", help="Stop after this many iterations"))
            if max_iter <= 0:
                st.warning("Max iterations must be positive")
                return
        except ValueError:
            st.warning("Please enter a valid integer")
            return
    
    with col2:
        try:
            plateau_limit = int(st.text_input("Plateau Limit", "100", help="Stop if no improvement for N iterations"))
            if plateau_limit <= 0:
                st.warning("Plateau limit must be positive")
                return
        except ValueError:
            st.warning("Please enter a valid integer")
            return
    
    with col3:
        seed = st.text_input("Random Seed (optional)", "", help="Leave empty for random start")
        if seed:
            try:
                import random
                random.seed(int(seed))
            except ValueError:
                st.warning("Seed must be an integer")
        
    # --- Run Hill Climbing ---
    if st.button("üü¢ Run Hill Climbing Algorithm"):
        
        # Progress animation
        progress = st.progress(0)
        status_text = st.empty()
        
        # Step 1: Generate random initial state
        status_text.text("üîπ Step 1: Generating random initial state...")
        time.sleep(0.3)
        progress.progress(10)
        
        initial_state = create_random_state()
        initial_cost = calculate_cost(initial_state, target_image)
        
        st.info(f"‚úÖ Generated random 10√ó10 binary image (initial cost: {initial_cost}/100 mismatched pixels)")
        
        # Step 2: Initialize Hill Climber
        status_text.text("üîπ Step 2: Initializing Hill Climbing algorithm...")
        time.sleep(0.3)
        progress.progress(20)
        
        # Wrap cost function to use selected target
        def cost_fn(state):
            return calculate_cost(state, target_image)
        
        climber = HillClimber(
            cost_function=cost_fn,
            neighbor_function=generate_neighbors,
            max_iterations=max_iter,
            plateau_limit=plateau_limit,
            use_stochastic=use_stochastic,
            sample_size=sample_size
        )
        
        # Step 3: Run algorithm
        status_text.text(f"üîπ Step 3: Running Hill Climbing (max {max_iter} iterations)...")
        progress.progress(30)
        
        try:
            result = climber.solve(initial_state, verbose=False)
            
            # Simulate progress updates
            progress.progress(90)
            time.sleep(0.3)
            status_text.text("‚úÖ Hill Climbing complete!")
            progress.progress(100)
            time.sleep(0.5)
            status_text.empty()
            progress.empty()
            
            # --- Display Results ---
            st.markdown("---")
            st.markdown("##### Results")
            
            # Metrics
            col_m1, col_m2, col_m3, col_m4 = st.columns(4)
            with col_m1:
                st.metric("Iterations", result.iterations)
            with col_m2:
                st.metric("Improvements", result.improvements)
            with col_m3:
                st.metric("Initial Cost", result.initial_cost)
            with col_m4:
                improvement_pct = ((result.initial_cost - result.final_cost) / result.initial_cost * 100) if result.initial_cost > 0 else 0
                st.metric("Final Cost", result.final_cost, delta=f"-{improvement_pct:.1f}%", delta_color="inverse")
            
            with st.container(border=True):
                st.markdown("#### Performance Metrics")
                col_performance1, col_performance2, col_performance3 = st.columns(3)
                with col_performance1:
                    st.metric("Execution Time", f"{result.execution_time:.4f} s")
                with col_performance2:
                    st.metric("Neighbors Evaluated", result.neighbors_evaluated)
                with col_performance3:
                    st.metric("Cost Evaluations", result.cost_evaluations)

            config_info = f"**Configuration:** {pattern_name} | {'Stochastic' if use_stochastic else 'Full'} Evaluation"
            if use_stochastic:
                config_info += f" ({sample_size} neighbors/iter)"
            st.caption(config_info)

            # Stop reason
            if result.final_cost == 0:
                st.success(f"üéâ **Perfect reconstruction!** {result.stop_reason}")
            elif improvement_pct > 90:
                st.success(f"‚úÖ **Excellent result!** {result.stop_reason}")
            elif improvement_pct > 70:
                st.info(f"üëç **Good result.** {result.stop_reason}")
            else:
                st.warning(f"‚ö†Ô∏è **Moderate result.** {result.stop_reason}")
            
            # --- Initial vs Final Comparison ---
            st.markdown("---")
            st.markdown("##### Initial vs Final State")
            
            col_init, col_final = st.columns(2)
            
            with col_init:
                st.caption("üìç Initial State (Random)")
                st.markdown(f"**Cost:** {result.initial_cost} mismatched pixels")
                st.code(format_state_text(result.initial_state), language="text")
                with st.expander("View as binary matrix"):
                    st.code(format_state_simple(result.initial_state), language="text")
            
            with col_final:
                st.caption("‚ú® Final State (Optimized)")
                st.markdown(f"**Cost:** {result.final_cost} mismatched pixels")
                st.code(format_state_text(result.final_state), language="text")
                with st.expander("View as binary matrix"):
                    st.code(format_state_simple(result.final_state), language="text")
            
            # --- Error Progression Plot ---
            st.markdown("---")
            st.markdown("##### Cost Progression")
            
            # EXTERNAL LIB EXCEPTION: Matplotlib for visualization only
            # Core algorithm is pure Python
            import matplotlib.pyplot as plt
            
            fig, ax = plt.subplots(figsize=(12, 5))
            ax.plot(result.cost_history, 'b-', linewidth=2, label='Cost (mismatched pixels)')
            ax.axhline(y=0, color='g', linestyle='--', linewidth=1, label='Perfect match')
            ax.set_xlabel('Iteration')
            ax.set_ylabel('Cost (Hamming Distance)')
            ax.set_title(f'Hill Climbing Progress: {result.initial_cost} ‚Üí {result.final_cost} mismatched pixels')
            ax.legend()
            ax.grid(True, alpha=0.3)
            ax.set_ylim(bottom=-5, top=max(result.cost_history) + 5)
            st.pyplot(fig)
            
            # Statistics
            st.caption(f"**Algorithm Stats:** {result.iterations} iterations, {result.improvements} improvements made")
            
            # --- Educational Hints ---
            st.markdown("""
            ---
            ### EigenAI's Hint üß†
            
            **Understanding Hill Climbing:**
            - **Local Search**: Explores neighboring states to find improvements
            - **Greedy Strategy**: Always moves to the best neighbor (steepest ascent)
            - **No Backtracking**: Once moved, never returns to previous states
            
            **Key Concepts:**
            - **State Space**: All possible 10√ó10 binary images (2¬π‚Å∞‚Å∞ states!)
            - **Cost Function**: Hamming distance = Œ£·µ¢‚±º |current[i][j] - target[i][j]|
            - **Neighborhood**: 100 neighbors (one per pixel flip)
            - **Local Optimum**: State where no single pixel flip improves cost
            
            **Why This Matters in AI:**
            - **Foundation of optimization**: Used in neural networks, planning, scheduling
            - **Trade-off**: Fast but may get stuck in local optima (vs. global search)
            - **Real applications**: Image processing, TSP, protein folding, game AI
            
            **Limitations:**
            - Cannot escape local optima (consider Simulated Annealing for that!)
            - No guarantee of finding global optimum
            - Performance depends on initial state and cost landscape
            """)
            
        except Exception as e:
            st.error(f"Algorithm failed: {e!s}")
            st.exception(e)
        
############################
constructor.py
############################

# constructor.py
# Binary Image Reconstruction Problem for Hill Climbing
# Pure Python implementation - no external libraries

import random
from typing import List, Tuple

# ========================================
# TARGET IMAGES (10x10 Binary Matrices)
# ========================================

# Pattern 1: Circle/Ring shape (SIMPLE - smooth cost landscape)
TARGET_IMAGE_SIMPLE = [
    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
    [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
    [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 0, 1],
    [1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
    [1, 0, 0, 1, 1, 1, 1, 0, 0, 1],
    [1, 0, 0, 0, 1, 1, 0, 0, 0, 1],
    [1, 1, 0, 0, 0, 0, 0, 0, 1, 1],
    [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],
    [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
]

# Pattern 2: Checkerboard (COMPLEX - more local optima, harder to optimize)
TARGET_IMAGE_COMPLEX = [
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
    [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
]

# Default target (for backwards compatibility)
TARGET_IMAGE = TARGET_IMAGE_SIMPLE


def get_target_image(use_complex: bool = False) -> List[List[int]]:
    """
    Get the target image based on complexity preference.
    
    Args:
        use_complex: If True, return complex checkerboard pattern.
                     If False, return simple circle pattern.
    
    Returns:
        List[List[int]]: The selected target image matrix
    """
    return TARGET_IMAGE_COMPLEX if use_complex else TARGET_IMAGE_SIMPLE

# ========================================
# STATE REPRESENTATION
# ========================================

def create_random_state(rows: int = 10, cols: int = 10) -> List[List[int]]:
    """
    Generate a random 10x10 binary matrix as initial state.
    Each pixel is randomly 0 or 1.
    
    Returns:
        List[List[int]]: A 10x10 matrix with random binary values
    """
    return [[random.randint(0, 1) for _ in range(cols)] for _ in range(rows)]


def copy_state(state: List[List[int]]) -> List[List[int]]:
    """
    Create a deep copy of the state matrix.
    
    Args:
        state: The matrix to copy
        
    Returns:
        List[List[int]]: A new matrix with same values
    """
    return [row[:] for row in state]


# ========================================
# COST FUNCTION (OBJECTIVE FUNCTION)
# ========================================

def calculate_cost(state: List[List[int]], target: List[List[int]] = TARGET_IMAGE) -> int:
    """
    Calculate the Hamming distance between current state and target.
    Cost = Number of mismatched pixels.
    
    Mathematical formulation:
        cost = Œ£·µ¢ Œ£‚±º |state[i][j] - target[i][j]|
    
    Args:
        state: Current image matrix
        target: Target image matrix (default: TARGET_IMAGE)
        
    Returns:
        int: Number of pixels that don't match (0 = perfect match)
    """
    # Optional: validating shapes before computing cost
    is_valid, msg = validate_state(state)
    if not is_valid:
        raise ValueError(f"Invalid state: {msg}")
        
    cost = 0
    rows = len(target)
    cols = len(target[0]) if rows > 0 else 0
    
    for i in range(rows):
        for j in range(cols):
            if state[i][j] != target[i][j]:
                cost += 1
    
    return cost


# ========================================
# NEIGHBOR GENERATION
# ========================================

def generate_neighbors(state: List[List[int]]) -> List[Tuple[List[List[int]], Tuple[int, int]]]:
    """
    Generate all possible neighbors by flipping one pixel at a time.
    For a 10x10 matrix, this produces 100 neighbors.
    
    Mathematical formulation:
        For each position (i,j):
            neighbor[i][j] = 1 - state[i][j]  (flip bit)
            neighbor[k][l] = state[k][l]      (keep all other bits)
    
    Args:
        state: Current state matrix
        
    Returns:
        List of tuples (neighbor_state, (row, col))
        where (row, col) is the pixel that was flipped
    """
    neighbors = []
    rows = len(state)
    cols = len(state[0]) if rows > 0 else 0
    
    for i in range(rows):
        for j in range(cols):
            # Create a copy and flip one pixel
            neighbor = copy_state(state)
            neighbor[i][j] = 1 - neighbor[i][j]  # Flip: 0‚Üí1 or 1‚Üí0
            neighbors.append((neighbor, (i, j)))
    
    return neighbors


# ========================================
# STATE UTILITIES
# ========================================

def format_state_text(state: List[List[int]]) -> str:
    """
    Format state as text grid for display.
    Uses ‚ñà for 1 and ‚ñë for 0 for better visualization.
    
    Args:
        state: Matrix to format
        
    Returns:
        str: Formatted string representation
    """
    lines = []
    for row in state:
        line = "".join(["‚ñà" if pixel == 1 else "‚ñë" for pixel in row])
        lines.append(line)
    return "\n".join(lines)


def format_state_simple(state: List[List[int]]) -> str:
    """
    Format state as simple 0/1 text grid.
    
    Args:
        state: Matrix to format
        
    Returns:
        str: Formatted string with 0s and 1s
    """
    lines = []
    for row in state:
        line = " ".join([str(pixel) for pixel in row])
        lines.append(line)
    return "\n".join(lines)


def states_equal(state1: List[List[int]], state2: List[List[int]]) -> bool:
    """
    Check if two states are identical.
    
    Args:
        state1: First matrix
        state2: Second matrix
        
    Returns:
        bool: True if matrices are identical
    """
    if len(state1) != len(state2):
        return False
    
    for i in range(len(state1)):
        if len(state1[i]) != len(state2[i]):
            return False
        for j in range(len(state1[i])):
            if state1[i][j] != state2[i][j]:
                return False
    
    return True


# ========================================
# VALIDATION
# ========================================

def validate_state(state: List[List[int]]) -> Tuple[bool, str]:
    """
    Validate that a state is a proper 10x10 binary matrix.
    
    Args:
        state: Matrix to validate
        
    Returns:
        Tuple[bool, str]: (is_valid, error_message)
    """
    if not state:
        return False, "State is empty"
    
    if len(state) != 10:
        return False, f"Expected 10 rows, got {len(state)}"
    
    for i, row in enumerate(state):
        if len(row) != 10:
            return False, f"Row {i} has {len(row)} columns, expected 10"
        
        for j, pixel in enumerate(row):
            if pixel not in (0, 1):
                return False, f"Pixel ({i},{j}) has value {pixel}, expected 0 or 1"
    
    return True, "Valid"

############################
hill_climber.py
############################

# hill_climber.py
# Reusable Hill Climbing Algorithm
# Pure Python implementation - no external libraries

from typing import List, Tuple, Callable, Any, Optional
import time
import random

class HillClimberResult:
    """
    Container for hill climbing results.
    """
    def __init__(self):
        self.initial_state: Any = None
        self.final_state: Any = None
        self.initial_cost: int = 0
        self.final_cost: int = 0
        self.iterations: int = 0
        self.cost_history: List[int] = []
        self.improvements: int = 0
        self.plateau_count: int = 0
        self.stop_reason: str = ""
        self.best_move_history: List[Tuple[int, int]] = []  # Track which pixels were flipped
        # Performance benchmarking
        self.execution_time: float = 0.0
        self.neighbors_evaluated: int = 0
        self.cost_evaluations: int = 0


class HillClimber:
    """
    Reusable Hill Climbing algorithm implementation.
    
    Hill Climbing Algorithm:
    1. Start with an initial state
    2. Evaluate all neighbors
    3. Move to the best neighbor if it improves cost
    4. Repeat until no improvement or stopping condition met
    
    Stopping Conditions:
    - Cost reaches zero (perfect solution)
    - Maximum iterations reached
    - Plateau limit reached (no improvement for N iterations)
    """
    
    def __init__(
        self,
        cost_function: Callable[[Any], int],
        neighbor_function: Callable[[Any], List[Tuple[Any, Any]]],
        max_iterations: int = 1000,
        plateau_limit: int = 50,
        use_stochastic: bool = False,
        sample_size: int = 100
    ):
        """
        Initialize Hill Climber with problem-specific functions.
        
        Args:
            cost_function: Function that takes a state and returns its cost (lower is better)
            neighbor_function: Function that takes a state and returns list of (neighbor, move_info)
            max_iterations: Maximum number of iterations before stopping
            plateau_limit: Stop if no improvement for this many iterations
            use_stochastic: If True, sample random neighbors when count > sample_size
            sample_size: Max neighbors to evaluate per iteration (stochastic mode)
        """
        self.cost_function = cost_function
        self.neighbor_function = neighbor_function
        self.max_iterations = max_iterations
        self.plateau_limit = plateau_limit
        self.use_stochastic = use_stochastic
        self.sample_size = sample_size
        
    def solve(self, initial_state: Any, verbose: bool = False) -> HillClimberResult:
        """
        Run hill climbing algorithm starting from initial_state.
        
        Args:
            initial_state: Starting state for the search
            verbose: If True, print progress information
            
        Returns:
            HillClimberResult: Object containing results and statistics
        """
        result = HillClimberResult()
        result.initial_state = initial_state
        
        # Initialize
        current_state = initial_state
        start_time = time.time()
        current_cost = self.cost_function(current_state)
        result.initial_cost = current_cost
        result.cost_history = [current_cost]
        # Count the initial cost evaluation as well
        result.cost_evaluations += 1

        plateau_counter = 0
        iteration = 0

        if current_cost == 0:
            result.final_state = current_state
            result.final_cost = current_cost
            result.iterations = iteration
            result.plateau_count = plateau_counter
            result.stop_reason = "Found optimal solution (cost = 0)"
            result.execution_time = time.time() - start_time
            return result
        
        if verbose:
            print("Starting Hill Climbing:")
            print(f"  Initial cost: {current_cost}")
            print(f"  Max iterations: {self.max_iterations}")
            print(f"  Plateau limit: {self.plateau_limit}")
            print()
        
        # Main hill climbing loop
        while iteration < self.max_iterations:
            iteration += 1
            
            # Generate all neighbors
            neighbors = self.neighbor_function(current_state)
            
            if not neighbors:
                result.stop_reason = "No neighbors generated"
                break
            
            # Find best neighbor
            best_neighbor = None
            best_cost = current_cost
            best_move = None
            
            # Stochastic sampling: if enabled and neighbors > threshold, sample randomly
            if self.use_stochastic and len(neighbors) > self.sample_size:
                neighbors_to_eval = random.sample(neighbors, self.sample_size)
                if verbose and iteration == 1:
                    print(f"  Using stochastic sampling: {self.sample_size} of {len(neighbors)} neighbors")
            else:
                neighbors_to_eval = neighbors
            
            for neighbor, move_info in neighbors_to_eval:
                result.neighbors_evaluated += 1
                neighbor_cost = self.cost_function(neighbor)
                result.cost_evaluations += 1
                
                if neighbor_cost < best_cost:
                    best_cost = neighbor_cost
                    best_neighbor = neighbor
                    best_move = move_info
            
            # Check if we found an improvement
            if best_neighbor is None:
                # No improvement found - we're at a local optimum
                plateau_counter += 1
                result.cost_history.append(current_cost)
                
                if verbose and iteration % 100 == 0:
                    print(f"  Iteration {iteration}: Cost={current_cost}, Plateau={plateau_counter}")
                
                # Check plateau limit
                if plateau_counter >= self.plateau_limit:
                    result.stop_reason = f"Plateau reached (no improvement for {plateau_counter} iterations)"
                    break
                    
            else:
                # Improvement found - move to better neighbor
                current_state = best_neighbor
                current_cost = best_cost
                result.cost_history.append(current_cost)
                result.improvements += 1
                result.best_move_history.append(best_move)
                
                # Reset plateau counter
                plateau_counter = 0
                
                if verbose and (iteration % 100 == 0 or current_cost == 0):
                    print(f"  Iteration {iteration}: Cost={current_cost} (improvement!)")
                
                # Check if we reached optimal solution
                if current_cost == 0:
                    result.stop_reason = "Optimal solution found (cost = 0)"
                    break
        
        # Check if we hit max iterations
        if iteration >= self.max_iterations and not result.stop_reason:
            result.stop_reason = f"Maximum iterations reached ({self.max_iterations})"
        
        # Store final results
        result.final_state = current_state
        result.final_cost = current_cost
        result.iterations = iteration
        result.plateau_count = plateau_counter
        result.execution_time = time.time() - start_time
        
        if verbose:
            print()
            print("Hill Climbing Complete:")
            print(f"  Stop reason: {result.stop_reason}")
            print(f"  Iterations: {result.iterations}")
            print(f"  Improvements: {result.improvements}")
            print(f"  Final cost: {result.final_cost}")
            print(f"  Cost reduction: {result.initial_cost - result.final_cost}")
            print(f"  Execution time: {result.execution_time:.4f} seconds")
            print(f"  Neighbors evaluated: {result.neighbors_evaluated}")
            print(f"  Cost evaluations: {result.cost_evaluations}")
        
        return result