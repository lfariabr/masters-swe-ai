############################
app.py
############################
import streamlit as st

st.set_page_config(
    page_title="EigenAI Portal",
    layout="centered",
    page_icon="ü§ñ",
    initial_sidebar_state="expanded"
)

from views import home, set1Problem1, set1Problem2, set2Problem1, set2Problem2, set3Problem1

# ---- Sidebar Header ----
logo_url = "https://github.com/lfariabr/masters-swe-ai/blob/master/2025-T2/T2-MFA/projects/eigenai/assets/logo2.png?raw=true"
# logo_url = "assets/logo2.png"
st.sidebar.image(logo_url, width="stretch")
st.sidebar.markdown("---")

# ---- Sidebar Menu ----
menu = st.sidebar.radio(
    "üìÇ Select a screen:", [
    "üåÄ Portal",
    
    # Assessment 2A
    "[set1]problem-1",
    "[set1]problem-2",
    
    # Assessment 2B
    "[set2]problem-1",
    "[set2]problem-2",
    
    # Assessment 3
    "ai-problem-set",
], index=0)

# ---- View Routing ----
if menu == "üåÄ Portal":
    home.display()

if menu == "[set1]problem-1":
    set1Problem1.display_s1p1()

if menu == "[set1]problem-2":
    set1Problem2.display_s1p2()

if menu == "[set2]problem-1":
    set2Problem1.display_s2p1()

if menu == "[set2]problem-2":
    set2Problem2.display_s2p2()
    
if menu == "ai-problem-set":
    set3Problem1.display_s3p1()

# ---- Footer ----
st.sidebar.markdown("---")
st.sidebar.markdown("[![LinkedIn](https://img.shields.io/badge/LinkedIn-%230077B5.svg?&style=for-the-badge&logo=linkedin&logoColor=white)](https://linkedin.com/in/lfariabr)")
st.sidebar.caption("luisfaria.dev")

############################
set2Problem1.py
############################
# set2Problem1.py
# CLI driver for Set 2 ‚Äì Problem 1 (definite integral of a general function)

import time
import streamlit as st
from resolvers.integrals import parse_function, integrate, ParseError, integrate, symbolic_integral

def display_s2p1():
    st.title("üìò Numerical Integration")
    st.caption("Set 2 ‚Äì Problem 1")
    
    st.markdown("""
    Let‚Äôs find the **definite integral** of a function using numerical methods.  
    EigenAI will help you approximate **‚à´[a to b] f(x)dx** using different techniques.

    > Tip: use Python syntax for the function, example: sin(x) + x**2
    """)
    
    expr = st.text_input(
        "üìù Enter Your Function: f(x) = ", 
        "x**2", 
        help="Examples: x**2, sin(x), cos(x), exp(x), x**3 - 2*x + 1"
    ).strip()

    col1, col2 = st.columns(2)
    with col1:
        a_str = st.text_input(
            "Lower bound a = ", 
            "0", 
            help="Examples: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
        ).strip()
    with col2:
        b_str = st.text_input(
            "Upper bound b = ", 
            "1", 
            help="Examples: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10"
        ).strip()

    try:
        a = float(a_str)
        b = float(b_str)
    except ValueError:
        st.warning("Please enter valid numeric bounds for a and b.")
        return

    col3, col4 = st.columns(2)
    with col3:
        method = st.selectbox("Method", ["adaptive", "simpson", "trapezoid"])
    with col4:
            n = None
            if method in ("trapezoid", "simpson"):
                try:
                    n = int(st.text_input(
                        "subintervals n (blank for default) = ",
                        "100",
                        help="Examples: 10, 100, 1000, 10000. Higher n = more accuracy but slower."
                    ).strip() or "100")
                    if n <= 0: 
                        st.warning("n must be positive")
                        n = None
                except ValueError:
                    st.warning("Please enter a valid integer for n.")
                    n = None

            eps = 1e-6
            if method.startswith("adaptive"):
                try:
                    eps = float(st.text_input(
                        "tolerance eps (default 1e-6) = ",
                        "1e-6",
                        help="Examples: 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1"
                    ).strip() or "1e-6")
                    if eps <= 0:
                        st.warning("eps must be positive")
                        eps = 1e-6
                except ValueError:
                    st.warning("Please enter a valid positive number for eps.")
                    eps = 1e-6
    if method == "adaptive":
        st.info("Adaptive method automatically adjusts accuracy.")
    else:
        st.info("Higher n = more accuracy but slower.")

    if st.button("üü¢ Compute Integral"):
        # Defensive programming
        if not expr:
            st.warning("Please enter a function expression.")
            return
        if a >= b:
            st.warning("Please enter a valid interval [a, b] with a < b.")
            return
        if method in ("trapezoid", "simpson") and n is None:
            st.warning("Please enter a valid number of subintervals n > 0.")
            return
        if method.startswith("adaptive") and eps <= 0:
            st.warning("Please enter a valid tolerance eps > 0.")
            return

        # All clear, let's compute
        st.info("Starting integration...")
        progress = st.progress(0)
        status_text = st.empty()
        for i in range(100):
            progress.progress(i + 1)
            if i == 25:
                status_text.text("üîπ Step 1: Parsing function expression...")
                time.sleep(1.1)
            elif i == 50:
                n_display = n if n is not None else "adaptive"
                status_text.text(f"üîπ Step 2: Subdividing interval into {n_display} parts...")
                time.sleep(1.1)
            elif i == 75:
                status_text.text(f"üîπ Step 3: Applying {method.replace('_', ' ').title()}...")
                time.sleep(1.1)
            time.sleep(0.01)
        try:
            f = parse_function(expr)
            val, evals, info = integrate(f, a, b, method=method, n=n, eps=eps)
            st.success(f"Result: ‚à´ f(x) from {a} to {b} = {val:.10f}")
            st.caption(f"Evaluations: {evals} | {info}")

            # Inside your try block, after numeric output:
            symbolic = symbolic_integral(expr)
            st.markdown("#### Symbolic Integral Result")
            st.latex(f"‚à´ {expr} \,dx = {symbolic}")

            # EXTERNAL LIB EXCEPTION: 
            # Note: This is a controlled use of external libraries for visualization only
            # The core integration logic is implemented from scratch without any external dependencies
            import numpy as np
            import matplotlib.pyplot as plt

            st.markdown("#### Function Visualization")

            x = np.linspace(a, b, 200)
            y = [f(xi) for xi in x]
            fig, ax = plt.subplots(figsize=(10, 6))
            ax.plot(x, y, 'b-', linewidth=2, label="f(x)")
            ax.fill_between(x, 0, y, alpha=0.3, color='lightblue')
            ax.set_xlabel('x')
            ax.set_ylabel('f(x)')
            ax.set_title(f'Function f(x) = {expr} on [{a}, {b}]')
            ax.grid(True, alpha=0.3)
            ax.legend()
            st.pyplot(fig)

            st.markdown("""
            ---
            ### EigenAi's Hint üß†
            
            **Choosing the Right Method:**
            - **Trapezoid Rule**: Simple and fast, but less accurate for curved functions. Good for smooth, linear-like functions.
            - **Simpson's Rule**: More accurate than trapezoid for smooth functions. Requires even number of intervals.
            - **Adaptive Simpson**: Best accuracy with automatic refinement. Focuses computation where the function changes most.
            
            **Tip:** For most cases, adaptive Simpson with default tolerance (1e-6) provides excellent results with minimal input!
            """)
            
        except (ParseError, ValueError, ZeroDivisionError) as e:
            st.error(f"Error: {e}")
############################
integrals.py
############################

# integrals.py
# Numerical integration without external libraries.
# Methods: composite trapezoid, composite Simpson, adaptive Simpson.
# Safe parsing of f(x) strings via a restricted math namespace.

import math
from typing import Callable, Tuple, Optional

_ALLOWED = {
    k: getattr(math, k) for k in dir(math)
    if not k.startswith("_")
}
_ALLOWED.update({
    "abs": abs,
    "min": min,
    "max": max
})

class ParseError(Exception):
    pass

def parse_function(expr: str) -> Callable[[float], float]:
    """
    Parse a user expression like 'sin(x) + x**2' into f(x).
    Only names in _ALLOWED and the variable 'x' are permitted.
    """
    expr = expr.strip()
    if not expr:
        raise ParseError("Empty function expression.")
    def f(x: float) -> float:
        local = {"x": x}
        return eval(expr, {"__builtins__": {}}, {**_ALLOWED, **local})
    # quick sanity check
    try:
        _ = f(0.0)
    except (NameError, SyntaxError, TypeError, ZeroDivisionError, AttributeError) as e:
        raise ParseError(f"Invalid function: {e}") from e
    return f

def trapezoid(f: Callable[[float], float], a: float, b: float, n: int) -> Tuple[float,int]:
    if n <= 0: 
        raise ValueError("trapezoid: n must be >= 1")
    h = (b - a) / n
    s = 0.5 * (f(a) + f(b))
    evals = 2
    for i in range(1, n):
        s += f(a + i*h); evals += 1
    return s * h, evals

def simpson(f: Callable[[float], float], a: float, b: float, n: int) -> Tuple[float,int]:
    if n < 2: raise ValueError("simpson: n must be >= 2 (even).")
    if n % 2 == 1: n += 1  # enforce even
    h = (b - a) / n
    s = f(a) + f(b)
    evals = 2
    # odd indices
    odd_sum = 0.0
    for i in range(1, n, 2):
        odd_sum += f(a + i*h); evals += 1
    # even indices
    even_sum = 0.0
    for i in range(2, n, 2):
        even_sum += f(a + i*h); evals += 1
    return (h/3.0) * (s + 4*odd_sum + 2*even_sum), evals

def _simpson_single(f: Callable[[float], float], a: float, b: float) -> Tuple[float,int]:
    c = (a + b) / 2.0
    fa, fb, fc = f(a), f(b), f(c)
    evals = 3
    return (b - a) * (fa + 4*fc + fb) / 6.0, evals

def adaptive_simpson(
    f: Callable[[float], float],
    a: float,
    b: float,
    eps: float = 1e-6,
    max_depth: int = 20
) -> Tuple[float,int,str]:
    """
    Adaptive Simpson with error estimate. Returns (value, evals, reason).
    """
    evals_total = 0

    def recurse(a,b,eps,depth,S,fa,fb,fc) -> Tuple[float,int,bool]:
        nonlocal evals_total
        c = (a + b) / 2.0
        left_mid  = (a + c) / 2.0
        right_mid = (c + b) / 2.0
        fL = f(left_mid); fR = f(right_mid)
        evals_total += 2

        Sleft  = (c - a) * (fa + 4*fL + fc) / 6.0
        Sright = (b - c) * (fc + 4*fR + fb) / 6.0
        if abs(Sleft + Sright - S) <= 15*eps or depth <= 0:
            return Sleft + Sright + (Sleft + Sright - S)/15.0, 0, True
        # Recurse
        val_left, _, okL = recurse(a,c,eps/2.0,depth-1,Sleft,fa,fc,fL)
        val_right, _, okR = recurse(c,b,eps/2.0,depth-1,Sright,fc,fb,fR)
        return val_left + val_right, 0, okL and okR

    # initial Simpson on [a,b]
    c = (a+b)/2.0
    fa, fb, fc = f(a), f(b), f(c)
    evals_total += 3
    S = (b - a) * (fa + 4*fc + fb) / 6.0
    val, _, ok = recurse(a,b,eps,max_depth,S,fa,fb,fc)
    reason = "tolerance reached" if ok else "max depth reached"
    return val, evals_total, reason

def integrate(
    func: Callable[[float], float],
    a: float,
    b: float,
    method: str = "adaptive",
    n: Optional[int] = None,
    eps: float = 1e-6,
    max_depth: int = 20
) -> Tuple[float,int,str]:
    if a == b:
        return 0.0, 1, "zero-length interval"
    if method == "trapezoid":
        if n is None: n = 100
        val, evals = trapezoid(func, a, b, n)
        return val, evals, f"trapezoid with n={n}"
    elif method == "simpson":
        if n is None: n = 100  # will be made even inside
        val, evals = simpson(func, a, b, n)
        return val, evals, f"simpson with n={n if n%2==0 else n+1}"
    elif method in ("adaptive", "adaptive_simpson"):
        val, evals, why = adaptive_simpson(func, a, b, eps=eps, max_depth=max_depth)
        return val, evals, f"adaptive_simpson: {why}, eps={eps}"
    else:
        raise ValueError("Unknown method. Use 'trapezoid', 'simpson', or 'adaptive'.")

# EXTERNAL LIB EXCEPTION:
# Used only for symbolic integration; core numerical methods are implemented from scratch
# The sympy library is used here solely for symbolic computation, not for numerical integration
from sympy import Expr, symbols, integrate as sy_integrate, sympify, SympifyError
from typing import Union

def symbolic_integral(expr_str: str) -> Union[Expr, str]:
    """
    Return the symbolic integral expression and its evaluated result.
    
    Args:
        expr_str (str): String representation of the mathematical expression to integrate
        
    Returns:
        sympy expression or str: The symbolic integral result, or error message
    """
    try:
        x = symbols('x')
        expr = sympify(expr_str)
        symbolic_result = sy_integrate(expr, x)
        return symbolic_result
    except (SympifyError, ValueError, TypeError) as e:
        return f"Could not compute symbolic integral: {e}"